# 代数的ブロックマルチカラー (ABMC) オーダリングの実装詳細

このドキュメントでは、SparseSolv で使用されている代数的ブロックマルチカラー (ABMC) オーダリング手法の数学的背景と C++ 実装の詳細について説明します。ABMC は、不完全コレスキー (IC) および対称ガウス・ザイデル (SGS) 前処理における前進代入および後退代入ステップを並列化するために不可欠です。

## 1. 理論的背景

### 1.1 並列三角行列解法の課題
ICCG のような反復ソルバーでは、前処理の適用に三角連立方程式を解く必要があります。
- 前進代入: $L y = x$ を解く
- 後退代入: $U z = y$ (または $L^T z = y$) を解く

これらの演算には本質的に強いデータ依存性があります。$y_i$ を計算するには、まず $L_{ij} \neq 0$ となる $j < i$ のすべての $y_j$ を知っている必要があります。このシーケンシャルな依存性のボトルネックにより、最新のマルチコア CPU でのノード内並列処理が厳しく制限されます。

### 1.2 マルチカラーリング
これらの依存関係を断ち切るための古典的なアプローチが **マルチカラーオーダリング (多色順序付け)** です。ドメイン (または行列表現されるグラフ) は、隣接する2つのノードが同じ色を持たないように色付けされます。
同じ色のノードは完全に独立しており、並列に更新できます。しかし、古典的なポイントベースのマルチカラーリングは、メモリアクセスが色に基づいて飛躍するため、キャッシュの局所性を破壊することがよくあります。

### 1.3 代数的ブロックマルチカラー (ABMC)
高い並列性と優れたキャッシュ局所性の両方を実現するために、SparseSolv は **ABMC** を実装しています (T. Iwashita, H. Nakashima, Y. Takahashi, IPDPS 2012 による研究に基づいています)。

核となるアイデアは、2 レベルの階層を導入することです。
1. **ブロッキング (集約):** 近くのノード (行) をコンパクトな「ブロック」にグループ化します。ブロック内では、データの局所性が維持され、方程式はシーケンシャルに解かれます。
2. **カラーリング:** 各 *ブロック* をノードとする隣接グラフを構築します。このブロックグラフに貪欲法によるグラフ彩色を適用します。同じ色のブロックは、完全に並列に処理できます。

この方法は幾何学的情報を必要とせず、NGSolve によって提供される代数的な行構造 (CSR 形式) のみで機能します。

---

## 2. 実装パイプライン

ABMC 構造は、`ICPreconditioner` (または `SGSPreconditioner`) の `setup()` フェーズ中に構築されます。作業は 4 つの主要なステージに分かれており、`sparsesolv/core/abmc_ordering.hpp` に実装されています。

### ステージ 1: 代数的ブロッキング (BFS 集約)
**目標:** $N$ 行を、それぞれ約 `block_size` 行のブロックに分割します。

幅優先探索 (BFS) を使用して、行列グラフ内で強く接続されている行を集約します。
1. 新しいブロックのシードとして、未割り当ての最初の行を選択します。
2. その隣接ノードを BFS キューに追加します。
3. キューから取り出し続け、ブロックサイズが `block_size` に達するまで、未割り当ての行を現在のブロックに追加します。
4. すべての行が割り当てられるまで繰り返します。

これにより、同じブロック内の行が多くの非ゼロ要素を共有することが保証され、シーケンシャルなローカル解法中に空間的局所性が維持されて L1/L2 キャッシュヒット率が最大化されます。

### ステージ 2: ブロックレベルの隣接グラフの構築
**目標:** ノードが「ブロック」であり、エッジがブロック間の依存関係を表す粗いグラフを作成します。

ブロック $A$ 内のいずれかの行が、ブロック $B$ 内のいずれかの行の列に非ゼロの要素を持つ場合、2 つのブロック $A$ と $B$ は隣接しています。
これは、ブロック内のすべての行を反復処理し、それらの非ゼロ列インデックスのブロック割り当てを確認することによって段階的に構築されます。結果は CSR 構造の `blk_row_ptr` と `blk_col_idx` として保存されます。

### ステージ 3: 貪欲法によるグラフ彩色
**目標:** 隣接するブロックが同じ色を共有しないように、各ブロックに色を割り当てます。

SparseSolv は、高効率のために **Forbidden-Color-Set (禁止色集合)** の貪欲法アプローチを使用しています。
- `target_colors` はユーザーが提案するパラメータです。下三角ブロックの最大次数がより多くの色を必要とする場合、アルゴリズムは数学的正確性を確保するために、安全に (かつ自動的に) 合計色数を拡張します。
- アルゴリズムは、使用可能な最も番号の若い色を各ブロックに割り当てます。
- 同じ色のブロックは `out_color_list` に集約されます。

*注: 複雑なメッシュでスケールが極端に変化する場合 (高度に圧縮された境界層など)、BFS ブロッキングによって高度に接続されたブロックグラフが生成され、必要な色数が `target_colors` を超えて増加する可能性があります。*

### ステージ 4: 行の置換と保存
**目標:** 最終的にフラット化された `ordering` および `reverse_ordering` 配列を作成します。

ソルバーの反復中に深いポインタ追跡を避けるために、最終的な実行スケジュールはメモリ上に線形にレイアウトされます。
- **レベル 1 (色):** 色 0 から 色 C-1 までソートされます (`color_offsets`)。
- **レベル 2 (ブロック):** 各色の中で、ブロックがリストされます (`block_offsets`)。
- **レベル 3 (行):** 各ブロックの中で、行は新しいグローバルインデックスが割り当てられる前に **元のインデックスによってソート** されます (`std::sort`)。このソートステップは、TLB ミスを最小限に抑え、キャッシュラインの利用率を向上させるために重要です。

---

## 3. 並列三角解法のロジック

ABMC スケジュールと置換された行列が準備されると、`ic_preconditioner.hpp` での実際の並列解法 (`forward_substitution_abmc` / `backward_substitution_abmc`) は次のようになります。

### 3.1 前進代入 ($L y = x$)
色 $c$ は色 $< c$ で計算された結果に依存する可能性があるため、色 (0 から C-1) は厳密に順番に処理する必要があります。
1 つのカラーループ内では、`ngsolve::ParallelFor` が使用され、利用可能なスレッド間でブロックが分配されます。

```cpp
// 1. 色に対するシーケンシャルな外側ループ
for (index_t c = 0; c < num_colors; ++c) {
    
    // 2. 現在の色のすべてのブロックに対する並列実行
    parallel_for(num_blocks_in_c, [&](index_t bidx) {
        
        // 3. ブロック内のシーケンシャルなローカル解法
        for (index_t ridx = row_begin; ridx < row_end; ++ridx) {
            index_t i = abmc_schedule_.block_rows[ridx];
            // 内積を実行し、y[i] を更新する
        }
    });
}
```

### 3.2 後退代入 ($L^T z = y$)
$L^T$ は上三角行列であるため、依存関係は逆に流れます。単純に色とブロックの実行順序を反転させます。
- 色は下に向かって処理されます: C-1 から 0 へ。
- 並列ブロックタスク内では、行は逆の順序で処理されます (`row_end` から `row_begin` へ)。

---

## 4. Reverse Cuthill-McKee (RCM) との相乗効果

ABMC 単独でも効果的ですが、純粋にトポロジーに基づいて機能します。メッシュの初期番号付けにより、関連する自由度 (DOF) が広大なメモリアドレスに分散している場合、結果として得られる BFS ブロックは依然として広いメモリ領域にまたがっている可能性があり、CG ループでの SpMV (疎行列ベクトル積) のパフォーマンスが低下します。

SparseSolv は、**RCM (Reverse Cuthill-McKee)** アルゴリズムを使用したオプションの事前パスをサポートしています。
1. **最初に RCM を適用:** 行列の帯域幅がグローバルに狭くなります。
2. **RCM 空間での ABMC の適用:** BFS ブロッキングは、すでに圧縮された RCM 行列で動作します。つまり、サイズ 128 の BFS ブロックには、メモリ内で物理的に非常に近い行が含まれることになります。
3. **合成置換 (Composite Permutation):** ソルバーのすべてのステップで RCM 置換と ABMC 置換を順番に適用するオーバーヘッドを防ぐために、`ICPreconditioner` は `composite_perm` 配列 (`元 -> RCM -> ABMC`) を計算します。前処理はこの単一の変換を $O(N)$ の操作で適用します。

この 2 層のアプローチ (帯域幅の縮小 + 並列ブロッキング) は、マルチスレッドの高速化とキャッシュラインの利用率の最適なバランスを達成することを目指しています。
